# 项目介绍



**项目的通用开发流程**

1. 产品经历设计产品原型
2. 讨论需求
3. 分模块设计接口
4. 写出接口文档
5. 将接口文档递给前端人员，前后端分离开发
6. 开发完毕进行测试
7. 测试完毕发布项目，由运维人员进行部署安装



**项目模块设置**

xuecheng-plus-project：项目根目录

parent：项目顶级父模块，共有下面 11 个子模块，这 11个子模块的物理位置和父模块parent一致

- auth：认证与授权模块，依赖于 base模块

- base：通用配置模块
- checkcode：验证码模块，依赖于 base模块
- content：内容模块
  - content-api：内容接口模块，依赖于 content-service模块
  - content-service：内容服务模块，依赖于 content-base模块
  - content-model：内容模型模块，依赖于 base模块
- gateway：网关模块，主要负责路由转发
- learning：学习模块
  - learning-api：学习接口模块，依赖于 learning-service模块
  - learning-service：学习服务模块，依赖于 learning-model模块、message-sdk模块 和 content-model模块
  - learning-model：学习模型模块，依赖于 base模块
- media：媒资模块
  - media-api：媒资接口模块，依赖于 media-service模块
  - media-service：媒资服务模块，依赖于 media-model 和 message-sdk模块
  - media-model：媒资模型模块，依赖于 base模块
- message-sdk：消息模块
- orders：订单模块
  - orders-api：订单接口模块，依赖于 orders-service模块
  - orders-service：订单服务模块，依赖于 orders-model模块 和 message-sdk模块
  - orders-model：订单模型模块，依赖于 base模块
- search：搜索模块，依赖于 base模块
- system：词典模块
  - system-api：词典接口模块，依赖于 system-service模块
  - system-service：词典服务模块，依赖于 system-model模块
  - system-model：词典模型模块，依赖于 base模块







# 项目全局配置

由于项目采用微服务架构，**所以不存在真正的全局配置，只有模块级配置**

假如在 system模块配置了允许跨域，而在与 system同级的 content模块模块没有配置，那么只有 system可以接受跨域请求，因为有相同父模块且两者之间没有依赖关系的子模块是相互独立的



## 模块跨域控制



GlobalCorsConfig.java

```java
package com.xuecheng.system.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

/**
 * @author Mr.M
 * @version 1.0
 * @description TODO
 * @date 2023/2/12 11:27
 */
@Configuration
public class GlobalCorsConfig {

    @Bean
    public CorsFilter corsFilter() {

        CorsConfiguration config = new CorsConfiguration();
        //允许白名单域名进行跨域调用
        config.addAllowedOrigin("*");
        //允许跨越发送cookie
        config.setAllowCredentials(true);
        //放行全部原始头信息
        config.addAllowedHeader("*");
        //允许所有请求方法跨域调用
        config.addAllowedMethod("*");
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
```



该跨域控制放在 system模块内，则所有对 system模块接口的请求都会添加允许跨域字段

跨域配置生效原理：

1. Spring 容器扫描到 `@Configuration` ，加载类内逻辑，`@Bean` 标注的 `corsFilter` 方法会创建 `CorsFilter` Bean ，并纳入 Spring 容器管理
2. 一旦创建完成，**在所有 HTTP 请求进入后端之前**，`CorsFilter` 就会生效，对请求做跨域规则校验
3. 修改响应头，让浏览器拿到合法跨域的响应，前端拿到数据并渲染



## 全局异常捕获



为了在服务器内部出现异常，给前端返回**统一的响应结果RestErrorResponse**，通常需要**自定义异常类XueChengPlusException**

为了将自定义异常类和系统异常类捕获，需要定义**异常捕获器GlobalExceptionHandler**

有的时候在抛出自定义异常时，以字符串的形式给出异常信息不够优雅，可以定义**异常枚举类CommonError**



通用错误消息：CommonError.java

```java
package com.xuecheng.base.exception;

/**
 * @description 通用错误信息
 * @author Mr.M
 * @date 2022/9/6 11:29
 * @version 1.0
 */
public enum CommonError {

    UNKOWN_ERROR("执行过程异常，请重试。"),
    PARAMS_ERROR("非法参数"),
    OBJECT_NULL("对象为空"),
    QUERY_NULL("查询结果为空"),
    REQUEST_NULL("请求参数为空");

    private String errMessage;

    public String getErrMessage() {
        return errMessage;
    }

    private CommonError( String errMessage) {
        this.errMessage = errMessage;
    }
}
```



学成在线项目异常类：XueChengPlusException.java

```java
package com.xuecheng.base.exception;

/**
 * @description 学成在线项目异常类
 * @author Mr.M
 * @date 2022/9/6 11:29
 * @version 1.0
 */
public class XueChengPlusException extends RuntimeException {
    public XueChengPlusException() {
        super();
    }

    public XueChengPlusException(String errMessage) {
        super(errMessage);
    }

    public String getErrMessage() {
        return super.getMessage();
    }

    public static void cast(CommonError commonError) {
        throw new XueChengPlusException(commonError.getErrMessage());
    }

    public static void cast(String errMessage) {
        throw new XueChengPlusException(errMessage);
    }
}
```





错误响应参数包装：RestErrorResponse.java

```java
package com.xuecheng.base.exception;

import java.io.Serializable;

/**
 * 错误响应参数包装
 */
public class RestErrorResponse implements Serializable {
    private String errMessage;

    public RestErrorResponse(String errMessage) {
        this.errMessage = errMessage;
    }

    public String getErrMessage() {
        return errMessage;
    }

    public void setErrMessage(String errMessage) {
        this.errMessage = errMessage;
    }
}
```



全局异常处理器：GlobalExceptionHandler.java

```java
package com.xuecheng.base.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * @description 全局异常处理器
 * @author Mr.M
 * @date 2022/9/6 11:29
 * @version 1.0
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * 捕获自定义异常
     * @param e 自定义异常
     * @return  RestErrorResponse
     */
    @ExceptionHandler(XueChengPlusException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public RestErrorResponse customException(XueChengPlusException e) {
        log.error("{}",e.getErrMessage(),e);
        return new RestErrorResponse(e.getMessage());
    }

    /**
     * 捕获系统异常
     * @param e 系统异常
     * @return  RestErrorResponse
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public RestErrorResponse systemException(Exception e) {
        log.error("【系统异常】{}",e.getMessage(),e);
        return new RestErrorResponse(e.getMessage());
    }
}
```



这4个类要放在同一个包下，在需要的模块创建即可

在上面的示例中，它位于 base模块，所有依赖于 base模块的模块（例如 content模块）都能直接使用该异常处理器



异常捕获原理：

1. `@RestControllerAdvice` 会让这个类 **监听所有 `@RestController` 里抛出的异常**，一旦有匹配的异常类型，就会进入对应的处理逻辑
2. `@ExceptionHandler(xxx.class)`：只要是`xxx`异常或者它的子类异常抛出，就会触发该方法



异常捕获流程：

1. 业务代码抛出异常
2. 进入异常捕获器，判断异常是哪种类型
3. 不论何种类型，都返回RestErrorResponse给前端



## 日期格式转换

 * 在PO对象中，日期相关的属性是LocalDateTime类型，LocalDateTime本身是日期，没有字符串格式的概念
 * 默认序列化 LocalDateTime 会是类似 2025-08-12T10:00:00.123 这样带 T 分隔符的格式（符合 ISO - 8601 标准 ）
 * 我们创建这个配置类，SpringBoot会自动让这个配置类生效，将LocalDateTime序列化成字符串后会是 "yyyy-MM-dd HH:mm:ss" 格式

```java
package com.xuecheng.base.config;

import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * 在PO对象中，日期相关的属性是LocalDateTime类型，LocalDateTime本身是日期，没有字符串格式的概念
 * 默认序列化 LocalDateTime 会是类似 2025-08-12T10:00:00.123 这样带 T 分隔符的格式（符合 ISO - 8601 标准 ）
 * 我们创建这个配置类，SpringBoot会自动让这个配置类生效，将LocalDateTime序列化成字符串后会是 "yyyy-MM-dd HH:mm:ss" 格式
 */
@Configuration
public class LocalDateTimeConfig {

    /*
     * 序列化内容
     *   LocalDateTime -> String
     * 服务端返回给客户端内容
     * */
    @Bean
    public LocalDateTimeSerializer localDateTimeSerializer() {
        return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
    }

    /*
     * 反序列化内容
     *   String -> LocalDateTime
     * 客户端传入服务端数据
     * */
    @Bean
    public LocalDateTimeDeserializer localDateTimeDeserializer() {
        return new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
    }


    // 配置
    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() {
        return builder -> {
            builder.serializerByType(LocalDateTime.class, localDateTimeSerializer());
            builder.deserializerByType(LocalDateTime.class, localDateTimeDeserializer());
        };
    }
}
```







## 统一参数校验

SpringBoot支持 JSR303参数校验规范，它由sprint-boot-starter-validation实现，它的底层使用Hibernate Validator，Hibernate Validator是Bean Validation 的参考实现



1、添加 sprint-boot-starter-validation依赖

~~~xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
~~~



2、在接口（controller层）中的参数添加 @Validated注解（或者在类上添加@Validated）

```java
@ApiOperation("新增课程基础信息")
@PostMapping("/course")
public CourseBaseInfoDto addCourseBase(@RequestBody @Validated AddCourseDto addCourseDto) {
    CourseBaseInfoDto courseBase = courseBaseInfoService.createCourseBase(200200L, addCourseDto);
    return courseBase;
}
```



3、在参数对象字段添加相应的规则

```java
import com.xuecheng.base.exception.ValidationGroups;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.Size;
import java.math.BigDecimal;


@Data
@ApiModel(value="AddCourseDto", description="新增课程基本信息")
public class AddCourseDto {

    @NotEmpty(groups = {ValidationGroups.Insert.class}, message = "添加课程名称不能为空")
    @NotEmpty(groups = {ValidationGroups.Update.class}, message = "修改课程名称不能为空")
    @ApiModelProperty(value = "课程名称", required = true)
    private String name;

    @NotEmpty(message = "适用人群不能为空")
    @Size(message = "适用人群内容过少",min = 10)
    @ApiModelProperty(value = "适用人群", required = true)
    private String users;

    @ApiModelProperty(value = "课程标签")
    private String tags;

    @NotEmpty(message = "课程分类不能为空")
    @ApiModelProperty(value = "大分类", required = true)
    private String mt;

    @NotEmpty(message = "课程分类不能为空")
    @ApiModelProperty(value = "小分类", required = true)
    private String st;

    @NotEmpty(message = "课程等级不能为空")
    @ApiModelProperty(value = "课程等级", required = true)
    private String grade;
}
```



4、如果参数字段不符合要求，会抛出`MethodArgumentNotValidException`异常，可以在上面定义的全局异常捕获器捕获并处理它

```java
package com.xuecheng.base.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @description 全局异常处理器
 * @author Mr.M
 * @date 2022/9/6 11:29
 * @version 1.0
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    /**
     * 捕获非法参数异常
     * @param e 非法参数异常
     * @return  RestErrorResponse
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public RestErrorResponse illegalArgument(MethodArgumentNotValidException e) {
        // 获取错误校验结果
        BindingResult bindingResult = e.getBindingResult();
        // 错误信息列表
        List<String> errList = new ArrayList<>();
        for (FieldError fieldError : bindingResult.getFieldErrors()) {
            errList.add(fieldError.getDefaultMessage());
        }
        // 错误信息
        String errStr = Arrays.toString(errList.toArray());
        log.error("{}",errStr,e);
        return new RestErrorResponse(errStr);
    }
}
```



























# 项目表格



项目所有的数据库都在同一个mysql服务器上，不同的微服务使用不同的数据库



## **系统数据库**

系统数据库只有一个表，该表用于定义各类系统属性及其对应的枚举值

dictionary：数据词典表，内容如下

| id   | name                 | code | item\_values                                                 |
| :--- | :------------------- | :--- | :----------------------------------------------------------- |
| 12   | 公共属性类型         | 000  | \[{"code":"1","codeInt":1,"desc":"使用态"},{"code":"0","codeInt":0,"desc":"删除态"},{"code":"-1","codeInt":-1,"desc":"暂时态"}\] |
| 13   | 对象的审核状态       | 002  | \[{"code":"002001","desc":"审核未通过"},{"code":"002002","desc":"未审核"},{"code":"002003","desc":"审核通过"}\] |
| 14   | 资源类型             | 001  | \[{"code":"001001","desc":"图片"},{"code":"001002","desc":"视频"},{"code":"001003","desc":"其它"}\] |
| 15   | 课程审核状态         | 202  | \[{"code":"202001","desc":"审核未通过"},{"code":"202002","desc":"未提交"},{"code":"202003","desc":"已提交"},{"code":"202004","desc":"审核通过"}\] |
| 16   | 课程收费情况         | 201  | \[{"code":"201000","desc":"免费"},{"code":"201001","desc":"收费"}\] |
| 17   | 课程等级             | 204  | \[{"code":"204001","desc":"初级"},{"code":"204002","desc":"中级"},{"code":"204003","desc":"高级"}\] |
| 18   | 课程模式状态         | 200  | \[{"code":"200002","desc":"录播"},{"code":"200003","desc":"直播"}\] |
| 19   | 课程发布状态         | 203  | \[{"code":"203001","desc":"未发布"},{"code":"203002","desc":"已发布"},{"code":"203003","desc":"下线"}\] |
| 20   | 订单交易类型状态     | 600  | \[{"code":"600001","desc":"未支付"},{"code":"600002","desc":"已支付"},{"code":"600003","desc":"已关闭"},{"code":"600004","desc":"已退款"},{"code":"600005","desc":"已完成"}\] |
| 21   | 课程作业记录审批状态 | 306  | \[{"code":"306001","desc":"未提交"},{"code":"306002","desc":"待批改"},{"code":"306003","desc":"已批改"}\] |
| 22   | 消息通知状态         | 003  | \[{"code":"003001","desc":"未通知"},{"code":"003002","desc":"成功"}\] |
| 23   | 支付记录交易状态     | 601  | \[{"code":"601001","desc":"未支付"},{"code":"601002","desc":"已支付"},{"code":"601003","desc":"已退款"}\] |
| 24   | 业务订单类型         | 602  | \[{"code":"60201","desc":"购买课程"},{"code":"60202","desc":"学习资料"}\] |
| 25   | 第三方支付渠道编号   | 603  | \[{"code":"603001","desc":"微信支付"},{"code":"603002","desc":"支付宝"}\] |
| 26   | 选课类型             | 700  | \[{"code":"700001","desc":"免费课程"},{"code":"700002","desc":"收费课程"}\] |
| 27   | 选课状态             | 701  | \[{"code":"701001","desc":"选课成功"},{"code":"701002","desc":"待支付"}\] |
| 28   | 选课学习资格         | 702  | \[{"code":"702001","desc":"正常学习"},{"code":"702002","desc":"没有选课或选课后没有支付"},{"code":"702003","desc":"已过期需要申请续期或重新支付"}\] |





## **课程内容数据库**

<img src="https://gitee.com/liuyun_wind/image/raw/master/image-20250812212155813.png" alt="image-20250812212155813" style="zoom: 50%;" align="left"/>

主要有12个表格：

- course_audit：课程审核表
- course_base：课程基础信息表
  - id：自增主键
  - company_id：课程所属机构id，在项目中为  1232141425
  - mt：大分类
  - st：小分类
  - grade：课程等级
  - teachmode：课程模式
  - audit_status：课程审核状态
  - status：课程发布状态
- course_category：课程分类表
- course_market：课程营销信息表
- course_publish：已发布课程发布表
  - status：课程发布状态，恒定为 已发布，编号 “203002”
- course_publish_pre：待发布课程表
  - status：课程状态，恒定为 已提交，编号 “202003”
- course_teacher：课程-教师关系表
- mq_message：用于 **消息队列（MQ）的消息持久化存储**
- mq_message_history：用于存储消息队列（MQ）消息的历史记录，主要用于归档已处理完成的消息
- teachplan：课程计划
- teachplan_media：用于关联课程计划与媒体资源
- teachplan_work：用于关联课程计划与作业信息













## **媒资管理数据库**

该数据库有5个表格

- media_files：媒资信息表。一个课程计划会关联一个媒资文件，下面是一些重要字段
  - id：既是文件的id，也是文件的 MD5值
  - file_type：文件类型，有图片、视频和 html
  - bucket：桶，只有 video 和 mediafiles 这两种类型
  - file_name：文件名（包括后缀）
  - file_id：文件的 MD5
  - file_size：文件大小，单位字节
  - audit_status：审核状态，固定已提交，编号 “202003”（这个字段没什么作用）
  - file_path：文件在minio上的存储路径（从 `/bucket/` 开始），不同类型的文件有不同的存储路径
    - 视频：`第一位md5/第二位md5/完整md5/文件名`
    - 分块：`第一位md5/第二位md5/完整md5/chunk/分块名`
    - 图片：`yyyy/mm/dd/完整md5.后缀`
    - html：`course/文件对应的课程id.html`
  - url：文件的访问路径（从 `/` 开始）
    - 视频：`/video/第一位md5/第二位md5/完整md5/文件名`
    - 分块：`/video/第一位md5/第二位md5/完整md5/chunk/分块名`
    - 图片：`/mediafiles/yyyy/mm/dd/完整md5.后缀`
    - html静态页面：`/mediafiles/course/文件对应的课程id.html`



- media_process：待处理任务表。表中的所有记录都是需要转码的 .avi格式的文件
  - status：文件状态。1 未处理，2 处理成功，3 处理失败，4 处理中。表中的记录状态不会为2，处理成功后记录会立刻移除，并添加到 media_process_history
  - fail_count：失败次数。文件处理失败次数如果等于3，那么就不会被处理



- media_process_history：任务处理成功表。表中的所有记录都是进过转码后的 .mp4格式文件，下面3个字段值都是固定的
  - statue：2
  - errormsg：null
  - fail_count：null



## **用户管理数据库**

xc_user：用户表，存储了系统用户信息，用户类型包括：学生、老师、管理员等

xc_role：角色表，存储了系统的角色信息，学生、老师、教学管理员、系统管理员等

xc_user_role：用户角色表，一个用户可拥有多个角色，一个角色可被多个用户所拥有

xc_menu：模块表，记录了菜单及菜单下的权限

xc_permission：角色权限表，一个角色可拥有多个权限，一个权限可被多个角色所拥有



注意：xc_permission.role_id = xc_user_role.role_id



示例1：

查询某个用户所拥有的权限

~~~sql
# 先在 xc_user_role 表中根据 user_id 查询用户的 role_id
# 在 xc_permission 表中根据 role_id 查出所有 menu_id
# 最后在 xc_menu 表中根据 menu_id 查出所有符合的记录

select * 
from xc_menu
where id in (select menu_id
             from xc_permission
             where role_id in (select role_id
                               from xc_user_role
                               where user_id = '49'));
~~~



## **学习数据库**

有 3 张表：

- xc_choose_course：选课记录表，只要用户点击"加入我的课程表"，就会在表中添加该选课记录
  - id：自增主键
  - course_id：课程id
  - company_id：机构id
  - order_type：选课类型。700001，免费课程；700002，收费课程
  - status：选课状态。701001，选课成功；701002，待支付
- xc_course_tables：我的课程表。如果课程是免费的，那么在添加选课记录后自动添加我的课程记录；如果课程是收费的，在添加选课记录后要求付完费用才能添加我的课程记录
  - id：自增主键
  - choose_course_id：选课记录id
  - user_id：用户id
  - company_id：机构id
- xc_learn_record：学习记录表，记录用户学习进度之类



## **订单数据库**

- xc_orders：订单表，一个订单对应一个订单记录
  - id：订单号
  - status：交易状态。601001，未支付；601002，已支付；601003，已退款
  - user_id：用户ID
  - order_type：订单类型。60201，购买课程；60202，学习资料
  - out_business_id：外部系统业务ID（就是选课记录的主键）
- xc_orders_goods：订单明细表，一个订单对应多个订单明细，一个订单可以有多件商品，有 xc_orders.id = xc_orders_goods.order_id
- xc_pay_record：支付记录表，与订单是一对一关系，有 xc_orders.id = xc_pay_record.order_id
  - id：交易支付表主键，自增
  - pay_no：本系统支付交易流水号
  - out_pay_channel：第三方支付渠道编号
  - order_id：商品订单号
  - currency：币种
  - status：支付状态
  - user_id：用户ID











# 内容管理模块



## 内容模块层级

![image-20250812220533519](https://gitee.com/liuyun_wind/image/raw/master/image-20250812220533519.png)









假设软件需要同时开发移动端、PC端，后端服务器通常只需要一个，用不同的VO接受前端传递的请求参数，然后将它们封装成相同的DTO，这样就实现了移动端与PC端的相同业务操作

![image-20250812231902906](https://gitee.com/liuyun_wind/image/raw/master/image-20250812231902906.png)







## 请求接口



### 课程管理



#### 1、分页查询课程基本信息

```json
// 请求方法与路径，请求体为application/json格式
POST http://localhost:63040/content/course/list?pageNo=1&pageSize=2
Content-Type: application/json

{
"auditStatus": "202004",
"courseName": "java",
"publishStatus":"203002"
}



// 响应体
{
  "items": [
    {
      "id": 18,
      "companyId": 1232141425,
      "companyName": null,
      "name": "java零基础入门v2.0",
      "users": "java小白java小白java小白java小白",
      "tags": "aa",
      "mt": "1-3",
      "st": "1-3-2",
      "grade": "200001",
      "teachmode": "200002",
      "description": "java零基础入门v2.0java零基础入门v2.0java零基础入门v2.0java零基础入门v2.0",
      "pic": "/mediafiles/2022/12/18/a61805e1360ab946def5471aaefc0a98.jpg",
      "createDate": "2019-09-04 09:56:19",
      "changeDate": "2022-12-18 12:19:10",
      "createPeople": null,
      "changePeople": null,
      "auditStatus": "202004",
      "status": "203002"
    }
  ],
  "counts": 1,
  "page": 1,
  "pageSize": 2
}
```



业务层代码流程：

- 从 `SecurityUtil`中取出用户对象（能调用课程分页查询说明这个用户是老师），然后从老师对象取出它所属的机构id（注意：course_teacher表里的老师是没有 company_id字段的，而 xc_user 中的用户都是有 comyany_id字段的，我想说的是这是两类不同的老师）由于课程基本信息和机构绑定，所以 课程管理下的接口都需要机构id作为参数

- 给查询条件对象`LambdaQueryWrapper<CourseBase> queryWrapper`添加查询参数
- 构造分页参数对象`IPage<CourseBase> page`
- 执行分页查询`courseBaseMapper.selectPage(page, queryWrapper);`
- 返回查询结果



#### 2、新增或修改课程

~~~json
### 创建课程
POST http://localhost:63040/content/course
Content-Type: application/json

{

  "mt": "",
  "st": "",
  "name": "",
  "pic": "",
  "teachmode": "200002",
  "users": "初级人员",
  "tags": "",
  "grade": "204001",
  "description": "",
  "charge": "201000",
  "price": 0,
  "originalPrice":0,
  "qq": "",
  "wechat": "",
  "phone": "",
  "validDays": 365
}

###响应结果如下
#成功响应结果如下
{
  "id": 109,
  "companyId": 1,
  "companyName": null,
  "name": "测试课程103",
  "users": "初级人员",
  "tags": "",
  "mt": "1-1",
  "mtName": null,
  "st": "1-1-1",
  "stName": null,
  "grade": "204001",
  "teachmode": "200002",
  "description": "",
  "pic": "",
  "createDate": "2022-09-08 07:35:16",
  "changeDate": null,
  "createPeople": null,
  "changePeople": null,
  "auditStatus": "202002",
  "status": 1,
  "coursePubId": null,
  "coursePubDate": null,
  "charge": "201000",
  "price": null,
  "originalPrice":0,
  "qq": "",
  "wechat": "",
  "phone": "",
  "validDays": 365
}
~~~





新增课程比较麻烦，涉及对数据库 course_base 表和 course_market表的操作

大体流程：

1. 根据请求参数 AddCourseDto对象 生成 CourseBase对象 和 CourseMarket对象，前者负责插入 course_base表，后者负责插入 course_market表
2. 在插入 course_base表时，先判断表中是否存在重复数据，如果重复，执行更新（因为课程营销可能会更改，比如课程原价100元，现价改为60元）
3. 添加成功后，再次去数据库查询 CourseBase对象 和 CourseMarket对象，将它们整合成 CourseBaseInfoDto对象，返回给前端









#### 3、根据课程id查询课程信息

```json
// GET请求，带路径参数
GET http://127.0.0.1:63040/content/course/1

// 响应体
{
  "id": 1,
  "companyId": 200200,
  "companyName": "",
  "name": "JAVA8/9/10新特性讲解",
  "users": "java爱好者,适合有一定java基础",
  "tags": "有个java 版本变化的新内容，帮助大家使用最新的思想和工具",
  "mt": "1-1",
  "st": "1-1-1",
  "grade": "204003",
  "teachmode": "200002",
  "description": "java爱好者,适合有一定java基础",
  "pic": "https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg",
  "createDate": "2025-08-13 15:28:01",
  "changeDate": "2025-08-13 15:38:16",
  "createPeople": "1",
  "changePeople": null,
  "auditStatus": "202002",
  "status": "203001",
  "charge": "201001",
  "price": 2.0,
  "originalPrice": 11.0,
  "qq": "1",
  "wechat": "1",
  "phone": "1",
  "validDays": 1,
  "mtName": "前端开发",
  "stName": "HTML/CSS"
}
```





#### 4、修改课程信息

```json
PUT http://127.0.0.1:63040/content/course
Content-Type: application/json

{
  "id": 40,
  "name": "SpringBoot核心",
  "users": "Spring Boot初学者",
  "tags": "Spring项目的快速构建",
  "mt": "1-3",
  "st": "1-3-2",
  "grade": "200003",
  "teachmode": "201001",
  "description": "课程系统性地深度探讨 Spring Boot 核心特性，引导小伙伴对 Java 规范的重视，启发对技术原理性的思考，掌握排查问题的技能，以及学习阅读源码的方法和技巧，全面提升研发能力，进军架构师队伍。",
  "pic": "https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg",
  "charge": "201001",
  "price": 0.01
}

###修改成功响应结果如下
#{
#  "id": 40,
#  "companyId": 1232141425,
#  "companyName": null,
#  "name": "SpringBoot核心",
#  "users": "Spring Boot初学者",
#  "tags": "Spring项目的快速构建",
#  "mt": "1-3",
#  "mtName": null,
#  "st": "1-3-2",
#  "stName": null,
#  "grade": "200003",
#  "teachmode": "201001",
#  "description": "课程系统性地深度探讨 Spring Boot 核心特性，引导小伙伴对 Java 规范的重视，启发对技术原理性的思考，掌握排查问题的技能，以及学习阅读源码的方法和技巧，全面提升研发能力，进军架构师队伍。",
#  "pic": "https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg",
#  "createDate": "2019-09-10 16:05:39",
#  "changeDate": "2022-09-09 07:27:48",
#  "createPeople": null,
#  "changePeople": null,
#  "auditStatus": "202004",
#  "status": "203001",
#  "coursePubId": 21,
#  "coursePubDate": null,
#  "charge": "201001",
#  "price": 0.01
#}
```

























### 课程分类管理

course_category表格

<img src="https://gitee.com/liuyun_wind/image/raw/master/image-20250813044012141.png" alt="image-20250813044012141" style="zoom:50%;" align="left"/>



#### 1、获取课程分类信息

~~~json
// 请求方法与路径
GET http://127.0.0.1:63040/content/course-category/tree-nodes

// 请求头
HTTP/1.1 200 
Content-Type: application/json
Transfer-Encoding: chunked
Date: Tue, 12 Aug 2025 20:33:48 GMT

// 响应体
[
  {
    "id": "1-1",
    "name": "前端开发",
    "label": "前端开发",
    "parentid": "1",
    "isShow": 1,
    "orderby": 1,
    "isLeaf": 0,
    "childrenTreeNodes": [
      {
        "id": "1-1-1",
        "name": "HTML/CSS",
        "label": "HTML/CSS",
        "parentid": "1-1",
        "isShow": 1,
        "orderby": 1,
        "isLeaf": 1,
        "childrenTreeNodes": null
      },
      {
        "id": "1-1-10",
        "name": "其它",
        "label": "其它",
        "parentid": "1-1",
        "isShow": 1,
        "orderby": 10,
        "isLeaf": 1,
        "childrenTreeNodes": null
      }
    ]
  },
  {
    "id": "1-10",
    "name": "研发管理",
    "label": "研发管理",
    "parentid": "1",
    "isShow": 1,
    "orderby": 10,
    "isLeaf": 0,
    "childrenTreeNodes": [
      {
        "id": "1-10-1",
        "name": "敏捷开发",
        "label": "敏捷开发",
        "parentid": "1-10",
        "isShow": 1,
        "orderby": 1,
        "isLeaf": 1,
        "childrenTreeNodes": null
      },
      {
        "id": "1-10-2",
        "name": "软件设计",
        "label": "软件设计",
        "parentid": "1-10",
        "isShow": 1,
        "orderby": 2,
        "isLeaf": 1,
        "childrenTreeNodes": null
      }
    ]
  }
]
~~~





**业务层核心代码**

1. 查询数据库（select * from course_category），返回单列节点集合，这时节点的childrenTreeNodes属性都为空
2. 将单列节点集合转为双列节点集合，同时排除根节点，键就是节点的id，值是节点本身，方便后面查询使用
3. 准备返回结果（单列节点对象）
4. 遍历原单列集合
   1. 如果节点的父id等于给定id（1），说明它是一级分类，那么直接将当前节点加入返回结果
   2. **在双列集合中找到当前节点的父节点**，如果父节点为空，进入下次循环；如果父节点不为空，执行下面操作
      1. 如果父节点的childrenTreeNodes为空，那么给父节点创建childrenTreeNodes
      2. 将当前节点添加到父节点



```java
public List<CourseCategoryTreeDto> queryTreeNodes(String id) {
    List<CourseCategoryTreeDto> courseCategoryTreeDtos = courseCategoryMapper.selectTreeNodes(id);
    
    //将list转map,以备使用,排除根节点
    Map<String, CourseCategoryTreeDto> mapTemp = courseCategoryTreeDtos.stream().filter(item->!id.equals(item.getId())).collect(Collectors.toMap(key -> key.getId(), value -> value, (key1, key2) -> key2));
    
    //最终返回的list
    List<CourseCategoryTreeDto> categoryTreeDtos = new ArrayList<>();
    
    //依次遍历每个元素,排除根节点
    courseCategoryTreeDtos.stream().filter(item->!id.equals(item.getId())).forEach(item->{
        if(item.getParentid().equals(id)){
            categoryTreeDtos.add(item);
        }
        
        //找到当前节点的父节点
        CourseCategoryTreeDto courseCategoryTreeDto = mapTemp.get(item.getParentid());
        if(courseCategoryTreeDto!=null){
            if(courseCategoryTreeDto.getChildrenTreeNodes() ==null){
                courseCategoryTreeDto.setChildrenTreeNodes(new ArrayList<CourseCategoryTreeDto>());
            }
            
            //下边开始往ChildrenTreeNodes属性中放子节点
            courseCategoryTreeDto.getChildrenTreeNodes().add(item);
        }
    });
    return categoryTreeDtos;
}
```







### 课程计划管理



#### 1、根据课程id获取课程计划

这个方法的查询语句非常复杂，我们先搞清楚表结构

TeachplanDto 节点对象关系

一级分类与二级分类是一对多关系、二级分类与媒资是一对一关系（一级分类没有媒资）

~~~
         一对多            一对一
一级分类  <---->  二级分类  <---->  媒资
~~~



查询数据表返回的最终的结构

一条 teachplan.one记录 对应 多条 teachplan.two记录，一条 teachplan.two 对应 一条 teachplan_media记录

由此我们知道 （teachplan one）应该和 （teachplan two）内连接，因为内连接严格遵守 （one.id = two.parent_id）（不会查出null记录）

（teachplan two）和（teachplan_media m1）使用左外连接，因为外连接不严格遵守 （one.id = two.parent_id），以二级节点为主，就算媒资为null，也要查出



下面以JSON的格式展示一个 **二级**TeachplanDto对象在封装前的样子

~~~json
[
  {
    "one_id": 247,
    "one_pname": "第4章",
    "one_parentid": 0,
    "one_grade": 1,
    "one_mediaType": null,
    "one_startTime": null,
    "one_endTime": null,
    "one_orderby": 4,
    "one_courseId": 74,
    "one_coursePubId": null,
    "two_id": 250,
    "two_pname": "第4-0小节",
    "two_parentid": 247,
    "two_grade": 2,
    "two_mediaType": null,
    "two_startTime": null,
    "two_endTime": null,
    "two_orderby": 2,
    "two_courseId": 74,
    "two_coursePubId": null,
    "mediaFilename": null,
    "teachplanMeidaId": null,
    "mediaId": null
  },
  {
    "one_id": 247,
    "one_pname": "第4章",
    "one_parentid": 0,
    "one_grade": 1,
    "one_mediaType": null,
    "one_startTime": null,
    "one_endTime": null,
    "one_orderby": 4,
    "one_courseId": 74,
    "one_coursePubId": null,
    "two_id": 252,
    "two_pname": "小节名称 [点击修改]",
    "two_parentid": 247,
    "two_grade": 2,
    "two_mediaType": null,
    "two_startTime": null,
    "two_endTime": null,
    "two_orderby": 3,
    "two_courseId": 74,
    "two_coursePubId": null,
    "mediaFilename": null,
    "teachplanMeidaId": null,
    "mediaId": null
  },
  {
    "one_id": 247,
    "one_pname": "第4章",
    "one_parentid": 0,
    "one_grade": 1,
    "one_mediaType": null,
    "one_startTime": null,
    "one_endTime": null,
    "one_orderby": 4,
    "one_courseId": 74,
    "one_coursePubId": null,
    "two_id": 249,
    "two_pname": "第4-1小节 ",
    "two_parentid": 247,
    "two_grade": 2,
    "two_mediaType": null,
    "two_startTime": null,
    "two_endTime": null,
    "two_orderby": 5,
    "two_courseId": 74,
    "two_coursePubId": null,
    "mediaFilename": null,
    "teachplanMeidaId": null,
    "mediaId": null
  }
]
~~~



**节点对象**

```java
import com.xuecheng.content.model.po.Teachplan;
import com.xuecheng.content.model.po.TeachplanMedia;
import lombok.Data;
import lombok.ToString;

import java.util.List;

/**
 * @description 课程计划树型结构dto，用于返回给前端，包含3部分：课程计划、媒体资源和子节点
 * 在查询时需要返回计划属性、子节点属性，媒资对象（1级节点通常没有媒资属性，从2级开始才有）
 * @author Mr.M
 * @date 2022/9/9 10:27
 * @version 1.0
 */
@Data
@ToString
public class TeachplanDto extends Teachplan {

    //课程计划关联的媒资信息
    TeachplanMedia teachplanMedia;

    //子结点
    List<TeachplanDto> teachPlanTreeNodes;

}
```



```xml
<!-- 课程分类树型结构查询映射结果 -->
<resultMap id="treeNodeResultMap" type="com.xuecheng.content.model.dto.TeachplanDto">
    <!-- 一级数据映射 -->
    <id     column="one_id"        property="id" />
    <result column="one_pname"      property="pname" />
    <result column="one_parentid"     property="parentid" />
    <result column="one_grade"  property="grade" />
    <result column="one_mediaType"   property="mediaType" />
    <result column="one_startTime"   property="startTime" />
    <result column="one_endTime"   property="endTime" />
    <result column="one_orderby"   property="orderby" />
    <result column="one_courseId"   property="courseId" />
    <result column="one_coursePubId"   property="coursePubId" />
    <!-- 一级中包含多个二级数据 -->
    <collection property="teachPlanTreeNodes" ofType="com.xuecheng.content.model.dto.TeachplanDto">
        <!-- 二级数据映射 -->
        <id     column="two_id"        property="id" />
        <result column="two_pname"      property="pname" />
        <result column="two_parentid"     property="parentid" />
        <result column="two_grade"  property="grade" />
        <result column="two_mediaType"   property="mediaType" />
        <result column="two_startTime"   property="startTime" />
        <result column="two_endTime"   property="endTime" />
        <result column="two_orderby"   property="orderby" />
        <result column="two_courseId"   property="courseId" />
        <result column="two_coursePubId"   property="coursePubId" />
        <association property="teachplanMedia" javaType="com.xuecheng.content.model.po.TeachplanMedia">
            <result column="teachplanMeidaId"   property="id" />
            <result column="mediaFilename"   property="mediaFilename" />
            <result column="mediaId"   property="mediaId" />
            <result column="two_id"   property="teachplanId" />
            <result column="two_courseId"   property="courseId" />
            <result column="two_coursePubId"   property="coursePubId" />
        </association>
    </collection>
</resultMap>
<!--课程计划树型结构查询-->
<select id="selectTreeNodes" resultMap="treeNodeResultMap" parameterType="long" >
    select
        one.id             one_id,
        one.pname          one_pname,
        one.parentid       one_parentid,
        one.grade          one_grade,
        one.media_type     one_mediaType,
        one.start_time     one_startTime,
        one.end_time       one_endTime,
        one.orderby        one_orderby,
        one.course_id      one_courseId,
        one.course_pub_id  one_coursePubId,
        two.id             two_id,
        two.pname          two_pname,
        two.parentid       two_parentid,
        two.grade          two_grade,
        two.media_type     two_mediaType,
        two.start_time     two_startTime,
        two.end_time       two_endTime,
        two.orderby        two_orderby,
        two.course_id      two_courseId,
        two.course_pub_id  two_coursePubId,
        m1.media_fileName mediaFilename,
        m1.id teachplanMeidaId,
        m1.media_id mediaId

    from teachplan one
             LEFT JOIN teachplan two on one.id = two.parentid
             LEFT JOIN teachplan_media m1 on m1.teachplan_id = two.id
    where one.parentid = 0 and one.course_id=#{value}
    order by one.orderby,
             two.orderby
</select>
```

不同标签的返回类型：

- resultMap + type
- collection + ofType
- association + javaType



resultMap对数据的处理：

MyBatis 会依据 **一级数据的唯一标识（比如 `one_id` ）** 去判断是否重复，当遇到相同 `one_id` 的行时，会把对应的二级数据（不同行里的二级部分）添加到同一个一级 `TreeNode` 对象的 `collection` 集合属性中，最终实现一个一级节点对象包含多个二级子节点的效果





#### 2、课程计划创建或修改

在新增计划时，前端会直接向后端传递课程内容默认值，这样就必须在新增之后才能修改名称（让前端偷到了懒）

第一个课程计划的排序值为1，也就是说**排序值从1开始**，后面的所有操作都要保证排序值连续



业务层代码逻辑：

1. 先从请求参数获取计划id
   1. 如果id为null，说明是新增。那么先查出当前计划的插入位置，设置好插入位置后插入数据库即可
   2. 如果id不为null，说明是修改，直接根据id修改



#### 3、上移课程计划

业务层代码逻辑：

1. 从数据库查出当前计划
   1. 如果当前计划的排序字段是0，说明是第一个计划，不能上移
   2. 当前计划的排序值不是0，查出当前计划的上一个计划，交换这两个计划的排序值，并更新数据库



#### 4、下移课程计划

业务层代码逻辑：

1. 从数据库查出当前计划
2. 查出当前计划的兄弟数（包括当前计划自己）
   1. 如果当前计划的排序值等于兄弟数，说明是最后一个计划，不能下移
   2. 当前计划不是最后一个计划，查出当前计划的下一个计划，交换这两个计划的排序值，并更新数据库



#### 5、删除课程计划

我们先处理待删除计划的兄弟排序值，然后删除计划

1. 从数据库查出当前计划
2. 查出当前计划的所有兄弟数（包括自己）
   1. 如果当前计划的排序值不等于兄弟数，说明还有比当前计划排序值更大的计划，需要将他们的排序值都减 1
3. 如果当前计划是一级计划，删除它的所有子计划，如果是二级计划而不需要
4. 删除当前计划，同时删除当前教学计划与媒资的绑定（不真正删除媒资）





#### 6、课程计划和媒资信息绑定

流程：

1. 使用 `BindTeachplanMediaDto`对象接收前端传递过来的 媒资文件id`mediaId`、媒资文件名称`fileName`、教学计划id`teachplanId`

2. 根据 教学计划id 查询绑定（`TeachplanMedia`对象）（一个教学计划只能有一个媒资文件）
   1. 如果绑定为空，需要先根据 教学计划id 查询教学计划，然后从教学计划获取 课程id，再设置几个参数，比如创建时间
3. 给`TeachplanMedia`对象设置前端传过来的参数，在根据 id 是否为空，选择插入或修改



### 课程预览发布管理

#### 1、课程预览接口

业务层代码：查出课程基础信息 + 课程计划 +  课程教师

接口层代码：接收服务层返回的 CoursePreviewDto 对象，并根据这个对象的值填充模版 course_template.ftl，最后返回ModelAndView对象



#### 2、课程提交审核接口

业务层代码：

1. 先根据 课程id 查询课程基础信息
2. 做校验，课程审核状态为审核中，不可以再次提交；不能跨机构提交课程；课程封面图片不能为空
3. 创建 预发布对象，将课程基础信息从 CourseBase对象 拷贝到 CoursePublishPre对象
4. 将JSON字符串的课程营销信息放入 CoursePublishPre中
5. 查询课程计划，将课程计划添加到 CoursePublishPre中
6. 设置预发布状态，教学机构id，大小分类名称
7. **选择更新或插入课程预发布记录**
8. **更新课程基本表中记录的审核状态**



课程提交后，如果想要发布，需要手动修改数据库中的 course_base.audit_status 为 “202004”，course_publish_pre.status 为 "202004"



#### 3、课程发布接口

业务层任务：

1. 根据 课程id 从 课程预发布表 查询
2. 做校验，预发布对象不能为空；不能跨机构发布课程；课程审核状态必须为 “202004”，即通过审核才能发布（通过审核需要手动修改数据库表）；
3. 向 课程发布表 写入数据
   1. 创建 课程发布对象
   2. 将 课程预发布对象 拷贝到 课程发布对象
   3. 将课程发布对象的 发布状态 改为 已发布
   4. **选择性的 插入或更新 课程发布记录**
4. **将 课程基础表 中的 课程发布状态 改为 已发布**
5. **保存 消息表 记录**
   1. 新增消息的第一个参数为 “course_publish”
   2. 第二个参数为 courseId，其余参数为null
6. **根据 课程id 删除 课程预发布表中的记录**







#### 4、查询课程发布信息





#### 5、获取课程发布信息接口





### 课程老师管理



#### 1、根据查询教师列表



#### 2、保存教师信息



#### 3、移除教师





## 课程发布任务

在 调用课程发布接口完成之后，课程会从 课程预发布表 移动到 课程发布表，同时 消息表也会有 课程记录



课程发布任务：

- 向 Elasticsearch写索引
- 向 Redis写缓存
- 将课程的静态页面上传到 Minio







# 系统词典模块



## 请求接口



### 词典管理控制器



#### 1、查询整个词典表





#### 2、根据code查询item\_values































# 通用模块

主要有4个包：

- config：通用配置，如日期格式转换
- exeception：异常处理，有异常处理器、自定义异常类、异常错误枚举类
- model：通用的模型类，比如分页参数对象，分页结果返回对象
- utils：工具包





# 媒资管理模块

媒资管理只需要管理三类媒资：

- 视频：一般就是 课程计划内容
- 图片：课程封面 或 老师头像
- html静态文件：就是 course_template.ftl模版文件



断点续传实现步骤：

1. 前端对文件分块
2. 前端使用多线程一块一块上传，上传前给服务端发一个消息校验检查分块是否上传，如果已上传则不再上传
3. 等所有分块上传完毕，服务器合并所有分块，校验分块完整性
4. 前端给服务器一个 MD5值，服务端合并文件后计算合并后文件的 MD5是否和前端传的一致，如果一样则说明文件是完整的，如果不一样说明可能由于网络丢包导致文件不完整，这时需要重新上传



分块文件清理

1. 在数据库中有一张表记录minio中存储的文件状态
2. 文件开始上传时会写入文件表，状态为上传中，上传完成会更新状态为上传完成
3. 当一个文件传了一半不再上传说明该文件没有上传完成，会有定时任务区查询文件表中的记录，如果文件未上传完整则删除minio中没有上传成功的文件目录





## 请求接口





### 大文件上传管理





#### 1、文件上传前检查接口

接口层：

- 接收前端传来的文件的md5值



业务层：

- 根据 md5 从数据库中查找
  - 如果记录不为空，再去 Minio上找。如果找到，告诉前端不用上传；如果没找到，说明数据异常，暂不处理
  - 如果记录为空，告诉前端可以上传



#### 2、分块上传前检查接口

接口层：

- 接收前端传递的 MD5值 和 分块序号



服务层：

- 先根据 文件的MD5 得到分块文件目录 （格式：`第一位md5/第二位md5/完整md5/chunk/`）
- 再拼出 分块文件的存储路径（格式：`第一位md5/第二位md5/完整md5/chunk/分块序号`）
- 去 Minio上获取这个分块
- 如果已存在，告诉前端不需要上传这个分块；如果不存在，告诉前端可以上传这个分块





#### 3、分块上传接口

上传文件前，先将文件写入磁盘，然后从磁盘读取并上传至 Minio服务器（我也不清楚为什么要这样搞）



接口层：

- 接收前端传递过来的参数

  -  MultipartFile file：分块文件
  - String fileMd5：完整文件的 md5
  - int chunk：分块序号

- 先在磁盘上创建临时文件

  ```java
  File tempFile = File.createTempFile("minio", ".temp");
  ```

- 将内存的分块文件拷贝到磁盘上

  ```java
  file.transferTo(tempFile);
  ```

- 获取临时文件路径
- 调用服务层上传分块文件方法



服务层：

- 接收从接口层传来的 文件MD5、分块序号 和 分块的绝对路径
- 获取 分块的存储路径（格式：`第一位md5/第二位md5/完整md5/chunk/分块序号`）
- 上传分块文件





#### 4、合并文件接口

接口层：

- 接收 完整的MD5、分块总数 和 原始文件名
- 因为 合并分块后，需要向数据库添加 记录，所以需要更多的信息，新建 `UploadFileParamsDto`对象，设置文件类型为视频类型，标签为 课程视频，标记为空就行，文件名为接收过来的 原始文件名
- 向服务层传递 机构id、文件md5、分块总数 和 `UploadFileParamsDto`对象



服务层：

- 获取 分块文件目录（格式：`第一位md5/第二位md5/完整md5/chunk/`）
- 使用 Minio 提供的SDK将 目录下的所有文件搜集
- 拼接 文件在Minio上的存储路径（格式：`第一位md5/第二位md5/完整md5/文件名`）

- 构造合并参数，执行合并操作（注意点：mino对于分块文件最小要求是5MB才能合并（最后一块不受此限制））
- 下载视频文件，计算下载文件的 md5，与前端传递的 md5比对，如果不同，说明上传有误，暂时不处理；如果相同，进行下一步操作
- 将 视频文件入库
  - 根据 MD5 去数据库查找，如果记录为空，执行下面操作
  - 填充记录字段，填充完后向数据库添加 媒资文件记录
  - 然后向 任务表添加 任务记录
    - 获取文件名称 和 文件扩展名
    - 获取 文件的Mimetype
    - 如果是avi视频，在 media_process 表添加一个记录

- 最后清理分块文件





### 媒资文件管理

#### 1、媒资列表查询接口

业务层代码：

- 构建查询条件，分页条件对象
- 执行分页查询
- 获取分页结果，返回分页结果





#### 2、图片上传接口









#### 3、媒资预览接口

根据文件的MD5去数据库查询存储路径，然后前端在前面添上 Minio服务器地址，最后在浏览器显示



#### 4、媒资删除接口

服务层：

- 根据文件的MD5 去 teachplan_media 中查找，如果有和该媒资绑定的计划，不允许删除；如果没有，执行下面操作
- 根据文件的MD5去 media_files 查找，如果为空，抛出文件不存在异常；不为空，继续执行
- 从查找记录中获取 桶 和 存储路径
- 向 Minio发起删除，删除之前先进行一次检查，查看Minio上是否有对应文件，如果没有，抛出异常，有则正常删除







## 课程发布任务任务



### 课程发布任务描述

1. 课程发布任务用于将 .avi格式的视频转码为 .mp4，并更新数据库信息
2. 课程发布任务的核心代码在业务层，不再接口层，因为它由调度中心直接控制
3. 在项目上线时，我们会在多台服务器部署，实现分布式任务处理。在开发阶段，直接创建一个服务的多个实例，让它们端口号不同，模拟分布式执行器





### 课程发布任务 CoursePublishTask

1、`coursePublishHandler`（ 课程发布任务入口）

- 该方法使用 `@XxlJob`标注，是具体的一个执行器
- 在方法动态获取分片参数，包括 该执行器的分片索引 和 总的分片数
- 调用 `process` 模版方法，传递分片参数 和 任务类型 





2、`execute`（执行任务内容）

- 接收 `process` 方法传递过来的 `MqMessage`，将其中的 `businessKey1`转为`courseId`
- 依次执行 课程静态化、添加课程索引 和 课程缓存
- 全部成功，返回true



3、`generateCourseHtml`（生成课程静态化页面并上传至文件系统）

- 进行消息幂等校验
- 生成静态页面
  - 准备模版
  - 准备数据，就是课程基本信息、课程计划信息、师资信息
  - 使用 `FreeMarkerTemplateUtils.processTemplateIntoString`方法将 数据对象 挂载到 指定名称下，并返回字符串格式模版
  - 创建 File 文件
- 上传静态页面
  - 使用 `MultipartSupportConfig.getMultipartFile()`方法将 File 对象转为 MultipartFile对象
  - 远程调用媒资服务的 `upload`方法
- 保存第一阶段状态



4、`saveCourseIndex`（保存课程索引信息）

- 进行消息幂等校验
- 查询课程发布表，将 课程发布对象 拷贝到 课程索引对象
- 调用远程接口，将 课程索引对象 上传到Elasticsearch
- 保存第二阶段状态



































# 认证授权模块



## 概念



微信扫码登录流程：

<img src="https://gitee.com/liuyun_wind/image/raw/master/image-20250819223202085.png" alt="image-20250819223202085" style="zoom: 50%;" align="left"/>







OAuth2协议

<img src="https://gitee.com/liuyun_wind/image/raw/master/image-20250819223330803.png" alt="image-20250819223330803" style="zoom:50%;" align="left"/>



OAuth2支持的授权模式：授权码模式、密码模式、简化模式和客户端模式





单点登录：

在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统



## 请求接口



### 1、注册管理



#### 1、注册接口

注册流程：

1. 将前端提交的注册信息使用 `UserRegisterDto`接收
2. 校验两个密码是否一致
3. 校验邮箱验证码
4. 利用邮箱查询用户
5. 用户不存在，则向数据库添加用户



#### 2、修改密码接口

主要过程：

1. 将前端提交的注册信息使用 `UserRegisterDto`接收
2. 校验邮箱、两次密码
3. 校验邮箱验证码
4. 利用邮箱从数据库查询用户
5. 修改密码





## OAuth的内置接口



在项目中引入了 SpringSecurity 和 OAuth2 的依赖后，OAuth会自动暴露一些接口，供客户端使用

在配置类中，我们可以适当修改对接口的使用



### 密码登录接口

#### 整体功能

这段代码实现了一个基于 **Spring Security + OAuth2 + JWT** 的自定义认证逻辑。

- 前端通过 `/oauth/token` 走 **密码模式** 请求令牌；
- 后端会根据不同的认证方式（目前有账号+密码+验证码）来选择对应的认证服务；
- 认证成功后，生成一个 **JWT 令牌**，令牌中携带用户的身份信息和权限。



#### 代码分层说明

1. `UserDetailsServiceImpl` （Spring Security 接入点）

- 实现了 `UserDetailsService`，是 Spring Security **加载用户信息的入口**；
- 在 `loadUserByUsername` 方法中：
  1. 把前端传过来的 JSON 字符串解析为 `AuthParamsDto`（统一认证参数对象）；
  2. 根据 `authType` 动态获取对应的认证服务 Bean（例如 `"password_authservice"`）；
  3. 调用认证服务执行认证，返回扩展的用户对象 `XcUserExt`；
  4. 再把用户对象转换成 `UserDetails`，交给 Spring Security 使用。

 这里的关键逻辑是 **认证策略模式**：不同认证方式（密码登录、短信登录、第三方登录）可以动态切换。



2. `PasswordAuthServiceImpl` （账号密码认证服务）

- 实现了 `AuthService` 接口，负责 **账号 + 密码 + 验证码** 的认证逻辑；
- 流程：
  1. 校验验证码是否为空并调用远程 `CheckCodeClient` 校验；
  2. 根据用户名查询数据库用户信息；
  3. 校验用户是否存在；
  4. 使用 `PasswordEncoder` 校验用户输入的密码与数据库存储的加密密码是否匹配；
  5. 如果认证通过，返回 `XcUserExt`（包含用户的扩展信息）。

 这是最常见的账号密码登录逻辑，增加了验证码校验。



3. `TokenConfig` （令牌配置）

- 定义了 OAuth2 的 **Token 存储方式**和 **签名规则**；
- 使用 `JWT` 存储 Token，而不是存数据库；
- 设置了：
  - 签名密钥（对称加密方式）；
  - Token 的有效期（12 小时），刷新 Token 的有效期（7 天）；
  - 把 `JwtAccessTokenConverter` 加入到 `TokenEnhancerChain`，保证令牌在生成和解析时一致。

 这一部分负责 **生成 JWT 并管理令牌**。







# 网关模块

网关模块用于路由转发、认证和维护白名单



## 路由转发

断言配置如下

~~~yaml
server:
  port: 63010 # 网关端口
spring:
  cloud:
    gateway:
#      filter:
#        strip-prefix:
#          enabled: true
      routes: # 网关路由配置
        - id: content-api # 路由id，自定义，只要唯一即可
          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址
          uri: lb://content-api # 路由的目标地址 lb就是负载均衡，后面跟服务名称
          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件
            - Path=/content/** # 这个是按照路径匹配，只要以/content/开头就符合要求
#          filters:
#            - StripPrefix=1
        - id: system-api
          # uri: http://127.0.0.1:8081
          uri: lb://system-api
          predicates:
            - Path=/system/**
#          filters:
#            - StripPrefix=1
        - id: media-api
          # uri: http://127.0.0.1:8081
          uri: lb://media-api
          predicates:
            - Path=/media/**
#          filters:
#            - StripPrefix=1
        - id: search-service
          # uri: http://127.0.0.1:8081
          uri: lb://search
          predicates:
            - Path=/search/**
#          filters:
#            - StripPrefix=1
        - id: auth-service
          # uri: http://127.0.0.1:8081
          uri: lb://auth-service
          predicates:
            - Path=/auth/**
#          filters:
#            - StripPrefix=1
        - id: checkcode
          # uri: http://127.0.0.1:8081
          uri: lb://checkcode
          predicates:
            - Path=/checkcode/**
#          filters:
#            - StripPrefix=1
        - id: learning-api
          # uri: http://127.0.0.1:8081
          uri: lb://learning-api
          predicates:
            - Path=/learning/**
#          filters:
#            - StripPrefix=1
        - id: orders-api
          # uri: http://127.0.0.1:8081
          uri: lb://orders-api
          predicates:
            - Path=/orders/**
#          filters:
#            - StripPrefix=1
~~~



## 认证校验

1.先引入 SpringSecurity 和 OAuth2的依赖



2.创建网关过滤器：GatewayAuthFilter.java，它要实现 GlobalFilter, Ordered  这两个接口

校验流程：

1. 在静态代码块中读取白名单，将它记录在一个 字符串数组
2. 重写 `filter` 方法，将请求路径与白名单比对，一致则直接放行，不校验 token；如果不在白名单，需要校验 token，token有效才能放行
   1. 从请求头中的 `Authorization`获取token
3. 凡是被拦截的请求都返回 401 UNAUTHORIZED



校验token的方法

~~~java
// TokenStore的方法，参数是token，返回值是有效的token
// 如果解析token失败，会抛出InvalidTokenException异常
OAuth2AccessToken readAccessToken(String tokenValue);
    
// OAuth2AccessToken的抽象方法，判断token是否过期
public abstract boolean isExpired()
~~~





**网关中的安全配置类**

由于引入SpringSecurity，所以需要手动放行所有请求

~~~java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;

@EnableWebFluxSecurity
@Configuration
public class SecurityConfig {

    /**
     * 安全拦截配置
     * 网关过滤器中用到了OAuth2的TokenStore，所以需要配置SpringSecurity过滤器链，放行所有请求
     * @param http
     * @return
     */
    @Bean
    public SecurityWebFilterChain webFluxSecurityFilterChain(ServerHttpSecurity http) {

        return http.authorizeExchange()
                .pathMatchers("/**").permitAll()    // 放行所有请求
                .and().csrf().disable().build();    // 禁用csrf
    }
}
~~~





# 验证码模块



## 接口



### 验证码管理



#### 1、生成图形验证码接口

1.`PicCheckCodeServiceImpl` 图形验证码服务类

- 重载方法：
  - 重写  `generate(CheckCodeParamsDto checkCodeParamsDto)` 方法
  - 重写  `setCheckCodeStore(CheckCodeStore checkCodeStore)`，使用Redis存储校验码
  - 重写  `setKeyGenerator(KeyGenerator keyGenerator)`，使用 `UUIDKeyGenerator`生成随机的校验码key值
  - 重写  `setCheckCodeGenerator(CheckCodeGenerator checkCodeGenerator)`，使用`NumberLetterCheckCodeGenerator`生成验证码

- 流程：
  - 调用子类写好的 `generate(CheckCodeParamsDto checkCodeParamsDto,Integer code_length,String keyPrefix,Integer expire)`，获取`GenerateResult`对象（这里会生成验证码和验证码的key并存储到数据库，将结果封装到`GenerateResult`对象）
  - 根据验证码创建 base64 格式的字符串
  - 将验证码封装成 `CheckCodeResultDto`对象返回给前端



#### 2、图像验证码校验接口

流程：

- 将前端传递过来的 key 和 code接收
- 使用抽象父类 `AbstractCheckCodeService`中的具体方法 `verify`校验
  - 检查 key 或 code 是否为空，如果为空，返回 false
  - 调用子类 `CheckCodeStore`中的 `get`方法根据 key 获取 code_l ，如果 code_l 为空，返回 false
  - 比对 code_l 和 code 是否相等，如果相等返回 true





#### 3、邮箱验证码生成接口

`EmailCheckCodeServiceImpl`：和`PicCheckCodeServiceImpl` 一样，重写了 `generate`、`setCheckCodeGenerator`、`setKeyGenerator`、`setCheckCodeStore`方法

流程：

- 调用父类实现的 `ganerate`方法，获取`GenerateResult`对象
- 调用 `JavaMailSender`中的 `send`方法发送邮箱
- 准备`CheckCodeResultDto`对象返回给前端







## 设计模式的使用



代码层次如图

<img src="https://gitee.com/liuyun_wind/image/raw/master/image-20250902161308037.png" alt="image-20250902161308037" style="zoom: 50%;" align="left" />



**策略模式**

`CheckCodeService `中的`CheckCodeGenerator`、`KeyGenerator`、`CheckCodeStore` 都是 **策略接口**

`AbstractCheckCodeService` 通过依赖注入这几个接口，真正的算法/存储实现（例如 `RedisCheckCodeStore`、`NumberLetterCheckCodeGenerator`、`UUIDKeyGenerator`）在运行时被替换。
 **好处**：不同验证码生成方式、不同 key 生成规则、不同存储方式都能灵活替换。



**模版方法模式**

`AbstractCheckCodeService` 中的 `generate`、`varify`都是模版方法，子类可以直接调用使用



**单一职责原则（SRP）**

- 各个角色拆分得很清晰：
  - `CheckCodeGenerator` → 专门生成验证码
  - `KeyGenerator` → 专门生成 key
  - `CheckCodeStore` → 专门负责存储
  - `AbstractCheckCodeService` → 串联流程







# 消息处理模块













# 学习模块



## 请求方法



### 学习过程管理

#### 1、获取视频接口

接受前端传过来的4个参数：用户ID、课程ID、教学计划ID、媒资ID

业务层代码：

- 根据 课程ID 查询课程信息，如果不存在，抛出异常
- 校验用户ID是否为空
- 如果用户ID不为空
  - 根据 用户ID和课程ID获取学习资格
  - 如果学习状态为 702001，返回视频
  - 如果学习状态为 702002，无法观看，由于没有选课或选课后没有支付
  - 如果学习状态为 702003，您的选课已过期需要申请续期或重新支付
- 用户ID为空
  - 检验课程是否免费，如果免费，直接返回视频
  - 如果收费，提示需要购买后才能观看



### 我的课程管理



#### 1、添加选课接口

接口层：

- 从 `SecurityUtil`查询用户
- 将 用户ID 和 课程ID 传给服务层



服务层：

- 使用远程接口根据 课程ID 查询 课程发布对象
- 获取收费标准
- 创建 选课记录对象
- 如果课程免费
  - 添加 选课记录
    - 根据 用户ID、课程ID、免费课程状态、选课成功状态 查询 选课记录，如果选课记录存在，则直接返回；如果不存在，执行下面操作
    - 设置 课程ID、课程名称、用户ID、机构ID、选课类型为 “700001”、添加时间、课程价格为0、课程有效期统一365天、选课状态为“701001”选课成功、开始服务时间为当前时间、服务结束时间为当前天加上365、备注为空
    - 添加选课记录
    - 返回选课记录
  - 添加到 我的课程表

- 如果 课程收费
  - 添加 选课记录
    - 根据 课程ID、用户ID、课程收费状态、课程待支付状态 查询选课记录，如果存在，则直接返回；如果不存在，则执行下面操作
    - 设置 课程ID、课程名称、用户ID、机构ID、选课类型为 “700002”，添加时间、课程价格、课程有效期、选课状态为“701002”待支付，开始服务时间为当前时间、服务结束时间为当前加上课程有效期
    - 添加 选课记录
    - 返回 选课记录
- 最后查询学习资格
  - 根据 课程ID 去我的课程表查询学习资格；如果为空，返回学习状态为 702002的XcCourseTablesDto
  - 如果不为空，校验是否过期，没过期正常返回；如果过期返回已过期的XcCourseTablesDto





#### 2、查询学习资格接口

流程：

- 在接口层查询用户信息
- 将 用户ID 和 课程ID 传给服务层
- 根据 用户ID 和 课程ID 去 我的课程表 中查询记录
- 如果记录为空，说明没有选课 或者 课程未支付
- 新建 `XcCourseTablesDto`对象，作为返回给前端的数据
- 将查询的记录 拷贝到 XcCourseTablesDto对象
- 检验课程是否过期，如果过期，需要设置设置XcCourseTablesDto的学习状态为702001；如果没有，设置为702003
- 最后返回







#### 3、我的课程表接口

接口层：

- 使用 `MyCourseTableParams`接收参数

- 取出用户信息，将用户信息存入 `MyCourseTableParams`对象中
- 调用服务层方法，同时传递 `MyCourseTableParams`对象



业务层：

- 取出分页参数，构造分页条件
- 取出 用户ID，根据 用户ID 构造查询条件
- 根据用户ID和分页参数执行分页查询
- 封装结果到 `PageResult<XcCourseTables>` 并返回给前端











## 监听支付结果通知

监听消息队列接收支付结果通知



- 从参数中获取消息、消息类型、订单类型
- 处理支付结果通知
- 获取选课id
- 添加选课
  - 根据 选课ID 查询选课记录
  - 如果选课记录中的支付状态为 701001，**将选课记录添加到我的课程表**
  - 如果选课记录中的支付状态为 701002未支付，**将其更改为701001，并添加到我的课程表**（正常1情况）



































# 搜索模块



## 请求接口





### 课程搜索管理



#### 1、课程搜索列表接口





### 课程索引管理







# 订单管理模块



## 请求方法



整个扫码下单流程：

1. 用户请求 `generatepaycode`接口，后端返回二维码给用户
2. 用户使用支付宝扫描二维码，向 `requestpay`接口发起请求，请求执行完毕后，用户支付宝刷新出支付界面，用户点击支付完毕后，向 `receivenotify`发起请求，通知后端服务器支付状况



### 订单管理

#### 1、生成支付二维码接口

业务层代码：

- 根据 用户id 和 商品信息 新增商品订单
  - 先从 订单表中根据 外部系统业务id 查询记录，如果不为空，直接返回记录；如果为空，继续执行（确保不重复支付）
  - 创建 `XcOrders`对象，设置 订单号、总价、创建时间、交易状态为601001未支付，用户id、订单类型、订单名称、订单描述、订单明细、订单外部系统id
  - **新增订单**
  - 将订单明细字符串转为  `List<XcOrdersGoods>`对象，遍历对象，给每一个对象的订单号都设置相同，然后插入 订单明细表
  - 返回 订单记录
- 根据订单记录添加支付记录
  - 检查订单是否为空，订单是否已支付，未支付，执行下面操作
  - 创建支付记录对象`XcPayRecord`，生成并填充本系统交易流水号、商品ID、订单名称、订单总价、币种（默认人民币“CNY）、创建时间、用户ID
  - **新增支付记录**
  - 返回支付对象
- 生成二维码
- 将支付记录 和 二维码 拷贝到 PayRecordDto后返回















#### 2、扫码下单接口

接口层：

- 接收 订单编号 和 请求体对象
- 根据 订单编号 查询 支付记录，如果为空，抛出异常
- 获取支付状态，如果为已支付，抛出已支付异常（防止课程重复支付）
- 构造 阿里云客户端对象，向阿里云下单接口发起http请求















#### 3、接收支付通知支付结果接口

接口层：

- 将字符串传递过来的 `HttpServletRequest request`取出（里面包含订单支付结果）
- 根据 订单支付结果、支付宝公钥等其他参数进行验签，如果验签结果为 `false`，直接返回，不做任何处理；验签结果为 `true`，继续下面操作
- 从 订单支付结果 中取出 商户订单号、支付宝交易号、appid、total_amount
- 如果 订单支付结果 中的 交易状态为 “TRADE_SUCCESS”，保存支付宝支付结果；否则直接返回



服务层：（保存支付宝支付结果）

- 取出 商品订单号，根据商品订单号 查询支付记录，如果为空，抛出异常；否则向下执行
- 比对支付金额，如果不一致，抛出异常；否则向下执行
- **修改支付记录**

- **将 关联的订单记录 中的支付状态改为已支付**
- **保存消息记录**
- 通知消息处理（由RabbitMQ通知）
  - **如果回调成功，清除消息记录**
  - 











# 项目部署



DevOps思想：开发协作



CI/CD：包含一个CI和两个CD

CI：Continuous Integration，持续集成

CD：Continuous Delivery 和 Continuous Deployment，分别是持续交付和持续部署





